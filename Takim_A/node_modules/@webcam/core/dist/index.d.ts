/**
 * Applies a set of audio and video constraints to the corresponding media stream tracks
 *
 * @return {Promise<void>}
 */
declare const applyMediaStreamConstraints: (stream: MediaStream, { video, audio }: MediaStreamConstraints) => Promise<void>;

declare const getConstraintsBySource: (constraints: MediaStreamConstraints) => Promise<MediaStreamConstraints>;

type GetMainCameraParams = RegExp | {
    front?: RegExp;
    back?: RegExp;
};
declare const DEFAULT_MAIN_CAMERA_REG_EXP: {
    back: RegExp;
    front: RegExp;
};
/**
 * Returns MediaDeviceInfo in accordance with the default or passed parameters
 *
 * @param {GetMainCameraParams} params - pattern for searching the main camera device info by its label
 * @param {boolean} isFrontCamera - should the front camera be searched (back by default)
 * @return {MediaDeviceInfo | undefined} main camera device info
 */
declare const getMainCamera: (params?: GetMainCameraParams, isFrontCamera?: boolean) => Promise<MediaDeviceInfo | undefined>;

type VideoResolutionSize = {
    width: number;
    height: number;
};
type CameraResolutionType = 'HD' | 'FHD' | 'QHD' | 'UHD';
type CameraResolutionMode = keyof ConstrainULongRange;
declare const VIDEO_RESOLUTION_SIZE: Record<CameraResolutionType, VideoResolutionSize>;
interface VideoTrackConstraintsOptions {
    cameraResolutionMode?: CameraResolutionMode;
    cameraResolutionType?: CameraResolutionType;
    mainCamera?: GetMainCameraParams | boolean;
    frontCamera?: boolean;
}
/**
 * Generates and returns video track constraints by passed options
 *
 * @param {GetMediaStreamConstraintsParams} options - options for constraints generating
 * @return {Promise<MediaStreamConstraints>} video track constraints
 */
declare const getVideoTrackConstraints: (externalConstraints: MediaTrackConstraints, { mainCamera: useMainCamera, frontCamera: useFrontCamera, cameraResolutionType, cameraResolutionMode }: VideoTrackConstraintsOptions) => Promise<MediaTrackConstraints>;

interface MediaTrackConstraintsOptions extends VideoTrackConstraintsOptions {
    muted?: boolean;
}
interface GetMediaStreamConstraintsParams {
    options?: MediaTrackConstraintsOptions;
    constraints?: MediaStreamConstraints;
}
/**
 * Generates and returns media stream constraints by passed options
 *
 * @param {GetMediaStreamConstraintsParams} params - parameters for constraints generating
 * @return {Promise<MediaStreamConstraints>} media stream constraints
 */
declare const getMediaStreamConstraints: ({ constraints: { video, audio, ...otherConstraints }, options: { muted, ...options } }?: GetMediaStreamConstraintsParams) => Promise<MediaStreamConstraints>;

declare const getDevices: () => Promise<MediaDeviceInfo[]>;

declare const getMediaTrackSources: () => Promise<MediaTrackSource[] | undefined>;

interface GetVideoFrameCanvasOptions {
    imageSmoothingEnabled?: boolean;
    mirrored?: boolean;
    height?: number;
    width?: number;
}
/**
 * Returns a canvas with a drawn image of the current video stream frame in accordance with the passed options
 *
 * @param {HTMLVideoElement} source - video element instance with provided media stream
 * @param {GetVideoFrameCanvasOptions} options - options for getting video frame canvas
 * @return {HTMLCanvasElement | undefined} video stream frame canvas
 */
declare const getVideoFrameCanvas: (source: HTMLVideoElement, { imageSmoothingEnabled, mirrored, ...options }?: GetVideoFrameCanvasOptions) => HTMLCanvasElement | undefined;

interface GetWebcamSnapshotOptions extends GetVideoFrameCanvasOptions {
    format?: 'image/webp' | 'image/png' | 'image/jpeg';
    quality?: number;
}
/**
 * Returns a base64 encoded string of the current video stream frame in the specified format and quality
 *
 * @param {HTMLVideoElement} source - video element instance with provided media stream
 * @param {GetWebcamSnapshotOptions} options - options for getting webcam snapshot
 * @return {string | undefined} media stream source
 */
declare const getWebcamSnapshot: (source: HTMLVideoElement, { format, quality, ...options }?: GetWebcamSnapshotOptions) => string | undefined;

/**
 * Checks the possibility of using any implementation of getUserMedia
 *
 * @return {boolean}
 */
declare const canGetUserMedia: () => boolean;

/**
 * Accepts custom parameters and uses getUserMedia to get an instance of the media stream
 *
 * @param {GetMediaStreamConstraintsParams} params - options for constraints generating
 * @param {GetMediaStreamConstraintsParams} timeLimitMs - Time limit for MediaStream request execution
 * @return {Promise<MediaStream>} media stream instance
 */
declare const getMediaStream: (params?: GetMediaStreamConstraintsParams, timeLimitMs?: number) => Promise<MediaStream>;

/**
 * Legacy per-browser implementation of Navigator.getUserMedia
 *
 * @return {Navigator['getUserMedia'] | undefined}
 */
declare const getUserMediaFunction: false | ((options: MediaStreamConstraints, success: (stream: MediaStream) => void, error: (exception: DOMException) => void) => Promise<MediaStream>) | undefined;
/**
 * Adds extra error handling and support for legacy getUserMedia implementation
 *
 * @return {Promise<MediaStream>}
 */
declare const getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;

/**
 * Checks for the presence of getUserMedia in Navigator.MediaDevices
 *
 * @return {boolean}
 */
declare const hasGetUserMedia: () => boolean;

/**
 * Stops and removes audio and video tracks from the stream
 *
 * @return {void}
 */
declare const stopMediaStream: (stream?: MediaStreamTrack | MediaStream) => void;

export { type CameraResolutionMode, type CameraResolutionType, DEFAULT_MAIN_CAMERA_REG_EXP, type GetMainCameraParams, type GetMediaStreamConstraintsParams, type GetVideoFrameCanvasOptions, type GetWebcamSnapshotOptions, type MediaTrackConstraintsOptions, VIDEO_RESOLUTION_SIZE, type VideoResolutionSize, type VideoTrackConstraintsOptions, applyMediaStreamConstraints, canGetUserMedia, getConstraintsBySource, getDevices, getMainCamera, getMediaStream, getMediaStreamConstraints, getMediaTrackSources, getUserMedia, getUserMediaFunction, getVideoFrameCanvas, getVideoTrackConstraints, getWebcamSnapshot, hasGetUserMedia, stopMediaStream };
